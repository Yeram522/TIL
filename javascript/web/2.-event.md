# 2. EVENT

## 1️⃣ event handler

### 1. 이벤트 핸들러 어트리뷰트

#### 이벤트 핸들러 등록

✅ <mark style="background-color:green;">이벤트 핸들러</mark> : 이벤트가 발생했을 때 브라우저에 호출을 위임한 함수&#x20;브라우저에게 이벤트 핸들러의 호출을 위임한 것을 이벤트 핸들러 등록이라고 하며,&#x20;등록하는 방법은 3가지다.



#### 이벤트 핸들러 어트리뷰트 방식

HTML 이벤트 핸들러 어트리뷰트 <mark style="color:green;">(on 접두사 + 이벤트 타입)</mark>값으로 <mark style="background-color:yellow;">**함수 호출문을 할당**</mark>하여 이벤트 핸들러를 등록하는 방식이다.\
&#xNAN;_<mark style="color:orange;">주의할 점은 함수 참조가 아닌 함수 호출문을 할당한다는 것이다.</mark>_

```html
<button onclick="alert('클릭했네?'); console.log('클릭했네?');">클릭해보세오</button>
<button onmouseover="hello('수강생');">마우스를 올려보세요</button>

<script>
    function hello(name){
        alert(`${name}님, 마우스 올리지 마세요~`);
    }
</script>
```



### 2. 이벤트 핸들러 프로퍼티 방식

이벤트 핸들러 프로퍼티 키는 이벤트 핸들러 어트리뷰트와 동일함 <mark style="color:green;">(on 접두사 + 이벤트 타입)</mark>\
<mark style="background-color:yellow;">**이벤트 핸들러 프로퍼티 함수를 바인딩하면 이벤트 핸들러가 등록**</mark>된다.

{% hint style="warning" %}
이벤트 핸들러 어트리뷰트 방식과 비교했을 때 HTML과 자바스크립트가 뒤섞이는 문제는 해결할 수 있지만\
&#xNAN;_<mark style="color:red;">**이벤트 핸들러 프로퍼티**</mark><mark style="color:red;">에</mark> <mark style="color:red;"></mark><mark style="color:red;">**하나의 이벤트 핸들러**</mark><mark style="color:red;">만</mark> <mark style="color:red;"></mark><mark style="color:red;">**바인딩**</mark> <mark style="color:red;"></mark><mark style="color:red;">할 수 있다는 단점</mark>_&#xC774; 있다.
{% endhint %}

```html
<button id = "btn">클릭해보세요</button>

<script>
    const $button = document.querySelector('#btn');

    $button.onclick = function(){
        alert('DOM 프로퍼티 방식으로 이벤트 핸들러 등록 왼료!')
    }

    $button.onclick = () => alert('이벤트 덮어쓰기?'); // ⭐ 하나만 연결 가능!
</script>
```



### 3. addEventLinstener 메소드 방식

<mark style="color:green;">**EventTarget.prototype.addEventListener**</mark> 메소드를 사용하여 이벤트를 등록할 수 있다.\
첫 번째 매개변수에는 <mark style="background-color:blue;">**이벤트 타입**</mark>, 두 번째 매개변수에는 <mark style="background-color:blue;">**이벤트 핸들러**</mark> 전달하고,\
마지막 매개변수에는 <mark style="background-color:blue;">**이벤트 전파 단계**</mark>를 지정할 수 있다.

이벤트 핸들러 프로퍼티에 바인딩 된 이벤트 핸들러에 아무런 영향을 주지 않는다.\
동일한 HTML 요소에서 발생한 동일한 이벤트에 대해 <mark style="background-color:yellow;">**addEventListener 메소드 방식**</mark>으로는\
<mark style="color:red;background-color:yellow;">**하나 이상의 이벤트 핸들러를 등록 할 수 있**</mark>으며 이 때 _**이벤트 핸들러는 등록된 순서대로 호출**_&#xB41C;다.

```html
<button id = "btn">클릭해보세요</button>
<script>
    const $button = document.getElementById('btn');
    $button.addEventListener('click', function(){
        alert('클릭했네?');
    })

    // ✅ 이벤트 핸들러 프로퍼티 방식 추가
    $button.onclick = function() {
        console.log('이벤트 핸들러 프로퍼티 방식으로 이벤트 핸들러 등록!');
    }

    // ✅ addEventListener 메소드 방식으로 하나 더 추가
    $button.addEventListener('click', function(){
        console.log('addEventListener 메소드 방식으로 이벤트 핸들러 등록!');
    })

    // ✅ 참조가 동일한 이벤트 핸들러를 중복 등록하면 하나의 핸들러만 등록된다.
    const handleMouseOver = () => console.log('button mouseover');
    $button.addEventListener('mouseover', handleMouseOver);
    $button.addEventListener('mouseover', handleMouseOver);
</script>
```

### 4. 이벤트 핸들러 제거

<mark style="color:green;">**removeEventListener**</mark>메소드에 전달한 인수는 addEventListener 메소드와 동일하며,_<mark style="color:red;">전달한 인수가 일치하지 않을 경우 이벤트 핸들러는 제거되지 않는다.</mark>_

```html
<button id = "btn">클릭해보세요</button>

<script>
    const $button = document.getElementById('btn');
    const handleClick = () => alert("클릭했대!");

    $button.addEventListener('click', handleClick);
    $button.removeEventListener('click',handleClick);
</script>
```



💡 <mark style="color:green;">**이벤트 핸들러 프로퍼티 방식**</mark>으로 등록한 이벤트 핸들러는 removeEventListener 메소드로 제거할 수 없고\
<mark style="color:red;background-color:yellow;">**이벤트 핸들러 프로퍼티에 null을 할당해서 이벤트를 제거**</mark>한다.

<pre class="language-html"><code class="lang-html">&#x3C;button id = "btn2">더블클릭해보세요&#x3C;/button>

&#x3C;script>
    const $button2 = document.getElementById('btn2');
    const handleDblClick = () => {
            alert('더블클릭했다!');
            }

    // ✅ 이벤트 핸들러 프로퍼티 방식으로 이벤트 핸들러 등록
    $button2.ondblclick = handleDblClick;

<strong>    $button2.removeEventListener('dbclick', handleClick); // 제거 X
</strong>
    $button2.ondblclick = null;

&#x3C;/script>
</code></pre>

## 2️⃣ event object

### 1. 이벤트 객체

이벤트 발생 시 이벤트에 관련한 다양한 정보를 가진 **이벤트 객체가 동적으로 생성**된다.\
생성된 이벤트 객체는 **이벤트 핸들러의 첫 번째 인수**로 전달된다.

```html
<h1 class="message"></h1>
<script>
    const $msg = document.querySelector('.message');

    function showCoords(e){
        console.log(e);
        $msg.textContent = `clientX : ${e.clientX}, clientY : ${e.clientY}`;
    }

    document.onclick = showCoords; // 이벤트 객체로 전달.
</script>
```

{% hint style="warning" %}
<mark style="color:orange;">이벤트 핸들러 어트리뷰트 방식으로 이벤트 핸들러를 등록</mark>했다면 <mark style="color:red;background-color:yellow;">**반드시 event라는 이름을 사용**</mark>해야 한다.\


```html
<div class="area" onclick="showDivCoods(event)">
        이 영역 내부를 클릭해보세요. 클릭한 좌표를 알려드릴게요.
</div>
<script>
        const $area = document.querySelector('.area');

        function showDivCoods(e){
            console.log(e);
            $area.textContent = `clientX : ${e.clientX}, clientY : ${e.clientY}`;
        }
</script>
```
{% endhint %}

### 2. 이벤트 핸들러 내부의 this

#### 이벤트 핸들러 어트리뷰트

이벤트 핸들러 어트리뷰트 방식의 경우 **이벤트 핸들러에 의해 일반 함수로 호출**되고&#x20;<mark style="background-color:yellow;">**일반 함수 내부의 this는 전역 객체 window를 가리킨다.**</mark>\
&#xNAN;_<mark style="color:red;">이벤트 핸들러 호출 시 인수로 전달한</mark> <mark style="color:red;"></mark><mark style="color:red;">**this**</mark><mark style="color:red;">는 이벤트를</mark> <mark style="color:red;"></mark><mark style="color:red;">**바인딩한 DOM 요소**</mark><mark style="color:red;">를 가리킨다.</mark>_

```html
<button onclick="handleClick1()">클릭해보세요</button>
<button onclick="handleClick2(this)">클릭해보세요</button>

<script>
    function handleClick1(){
        console.log(this);
    }

    function handleClick2(button){
        console.log(button);
    }
</script>
```



#### 이벤트 핸들러 프로퍼티, addEventListener

이벤트 핸들러 프로퍼티 방식과 addEventListener 메소드 방식 모두 <mark style="background-color:yellow;">**이벤트 핸들러 내부의 this는&#x20;이벤트를 바인딩한 DOM 요소를 가리킨다**</mark>.\
&#xNAN;_<mark style="color:red;">즉,</mark> <mark style="color:red;"></mark><mark style="color:red;">**이벤트 핸들러 내부의 this**</mark><mark style="color:red;">는</mark> <mark style="color:red;"></mark><mark style="color:red;">**이벤트 객체의 currentTarget 프로퍼티**</mark><mark style="color:red;">와 같다</mark>_.

```html
<button id = "btn1">클릭해보세요</button>
<button id = "btn2">클릭해보세요</button>

<script>
    const $btn1 = document.getElementById('btn1');
    const $btn2 = document.getElementById('btn2');

    // ✅ 이벤트 핸들러 프로퍼티 방식
    $btn1.onclick = function(e) {
        console.log(this);
        console.log(e.currentTarget);
        console.log(this === e.currentTarget);
    }

    // ✅ addEventListener 메소드 방식
    $btn2.addEventListener('click', function(e){
        console.log(this);
        console.log(e.currentTarget);
        console.log(this === e.currentTarget);
    })
</script>
```
