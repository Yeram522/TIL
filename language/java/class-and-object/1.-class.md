# 1. Class

## 1️⃣ 클래스

{% code title="✅ 사용자 정의 클래스" %}
```java
public class Member {
    String id;
    String pwd;
    String name;
    int age;
    char gender;
    String[] hobby;
}
```
{% endcode %}

&#x20;

### 변수를 이용한 회원 데이터 관리

변수를 이용해서 데이터를 하나씩 저장 할 수 있지만,&#x20;

```java
String id = "user01";
String pwd = "pass01";
String name = "홍길동";
int age = 20;
char gender = '남';
String[] hobby = {"축구","볼링","테니스"};

System.out.println("id = " + id);
System.out.println("pwd = " + pwd);
System.out.println("name = " + name);
System.out.println("age = " + age);
System.out.println("gender = " + gender);

for(int i = 0; i < hobby.length; i++){
    System.out.print(hobby[i]+ " ");
}

System.out.println();
```

### 2. 사용자 정의의 자료형 사용하기

사용자 정의 클래스를 이용하여 자료들을 묶어서 관리할 수 있다.

#### 변수 선언 및 객체 생성

<mark style="color:purple;">`자료형 변수명 = new 클래스명();`</mark> _<mark style="color:green;">// 객체를 생성하는 구문이다.</mark>_\
사용자 정의의 자료형인 클래스를 이용하기 위해서는 <mark style="background-color:purple;">**new 연산자**</mark>로 <mark style="background-color:purple;">**heap 메모리 공간에 할당**</mark>을 해야 한다.\
객체를 생성하게 되면 클래스에 정의한 **필드**와 **메소드** 대로 <mark style="background-color:yellow;">**객체(instance)가 생성**</mark>된다.\
위의 _<mark style="color:red;">회원 정보들을 연속된 메모리 주소에서 사용</mark>_&#xD558;도록 heap에 공간을 다음과 같이 만들 수 있다.

```java
Member member = new Member();
```

#### 생성된 인스턴스의 초기값 확인하기

이렇게 객체를 생성하고 나면 서로 다른 자료형들을 하나의 member라는 이름으로\
관리할 수 있도록 공간을 생성한 것이다.\
&#xNAN;_<mark style="color:red;">heap에 생성되기 때문에 jvm 기본값으로 초기화 된다.</mark>_

필드에 접근하기 위해서는 <mark style="color:purple;">`래퍼런스변수명.필드명`</mark>으로 접근한다.\
<mark style="color:purple;">`'.'`</mark>은 참조연산자라고 하는데, _<mark style="color:green;">레퍼런스 변수가 참고하고 있는 주소로 접근한다는 의미를 가진다.</mark>_\
<mark style="background-color:yellow;">**각 공간은 필드명으로 접근**</mark>한다.(_배열은 인덱스로 접근, 객체는 필드명으로 접&#xADFC;_&#xD55C;다. )

```java
System.out.println(member.id);
System.out.println(member.pwd);
System.out.println(member.name);
System.out.println(member.age);
System.out.println(member.gender);
System.out.println(member.hobby);
```

#### 필드에 접근해서 변수 사용하듯이 사용하기

```java
member.id = "user01";
member.pwd = "pass01";
member.name = "홍길동";
member.age = 20;
member.gender = '남';
member.hobby = new String[] {"축구","볼링","테니스"};


System.out.println(member.id);
System.out.println(member.pwd);
System.out.println(member.name);
System.out.println(member.age);
System.out.println(member.gender);

for(int i = 0; i < member.hobby.length; i++){
    System.out.print(member.hobby[i] + " ");
}
```

## 2️⃣ 캡슐화(encapsulation)

### 1. 캡슐화의 필요성

#### \[ 1 ] 필드에 올바르지 않은 값이 들어가도 통제가 불가능하다.

```java
Monster monster2 = new Monster();
monster2.name = "드라큘라";
monster2.hp = -200; /* hp는 음수가 될 수 없지만, 직접 필드에 접근해
 값을 수정하게 되는 경우 통제 할 수 없다.*/

Monster monster3 = new Monster();
monster3.name = "뿌꾸";
monster3.setHp(-200);
```

```java
public class Monster {
    String name;
    int hp;

    // set 함수를 통해 예방할 수 있지만, 여전히 직접 접근이 가능하다.
    public void setHp(int hp){
        if(hp > 0){
            System.out.println("양수값이 입력되어 몬스터의 체력을 입력한 값으로 변경합니다.");
            this.hp = hp;
        }else{
            System.out.println("0보다 작거나 같은 값이 입력되어 몬스터의 체력을 0으로 변경합니다.");
        }
    }
}
```

#### \[ 2 ] 사용자 지정 클래스의 일부를 수정 했을 때, 해당 필드를 사용하는 모든 코드를 전부 수정해야하는 부담이 생긴다.&#x20;

이는 유지보수에 악영향을 미친다!

<figure><img src="../../../.gitbook/assets/image (79).png" alt=""><figcaption><p>String name을 kind로만 바꿨을 뿐이지만 고쳐야 할 것이 많이 생겼다.</p></figcaption></figure>

### 2. 캡슐화의 역할

#### \[ 1 ]  setter, getter 메서드

set,get 메서드를통해 필드 값을 직접 접근하여 읽기/쓰기 하는 것을 대신할 수 있다.

{% code title="✅ 사용자 지정 클래스" %}
```java
public class Monster {

    String name;
    int hp;

    public void setInfo(String name){
        this.name = name;
    }

    public void setHp(int hp){
        if(hp > 0){
            this.hp = hp;
        }else{
            this.hp = 0;
        }
    }
    public  String getInfo(){

        return "몬스터의 이름은" + this.name + "이고, 체력은" + this.hp + "입니다.";
    }
}
```
{% endcode %}

```java
Monster monster1 = new Monster();
monster1.setInfo("드라큘라");
monster1.setHp(200);

Monster monster2 = new Monster();
monster1.setInfo("프랑캔슈타인");
monster1.setHp(200);

Monster monster3 = new Monster();
monster1.setInfo("늑대인간");
monster1.setHp(-300);
```

잘못 된 값으로 필드 값을 지정 해 줄 경우, set 메서드가 동작하여 잘 못된 값이 들어가지 않도록 한다.

#### \[ 2 ] 접근 제한자

하지만 set,get 함수를 사용하지 않고도 `.` 참조연산자를 이용해 여전히 필드 값을 직접 바꿀 수 있다.&#x20;

이를 막기 위해서, 접근 제한자를 이용해 직접 필드에 접근할 수 없도록 강제화 할 수 있다.

<mark style="background-color:yellow;">💡</mark>  <mark style="background-color:yellow;"></mark><mark style="background-color:yellow;">**접근제한자**</mark>

클래스 혹은 클래스의 멤버 참조연산자로 접근할 수 있는 <mark style="color:purple;">범위를 제한하기 위한 키워드</mark>

<table><thead><tr><th width="99.66665649414062">종류</th><th>역할</th></tr></thead><tbody><tr><td><strong>public</strong></td><td>모든 패키지에 접근 혀용</td></tr><tr><td><strong>protected</strong></td><td>동알 패키지에 접근 혀용. 단, 상속관계에 있는 경우 다른 패키지에서도 접근 가능</td></tr><tr><td><strong>default</strong></td><td>동일 패키지에서만 접근 혀용. ( 작성하지 않는 것이 default )</td></tr><tr><td><strong>private</strong></td><td>해당 클래스 내부에서만 접근 허용</td></tr></tbody></table>

위의 4가지 접근제한자는 클래스의 멤버(필드, 메소드)에 모두 사용 가능하다.\
✨ _<mark style="color:red;background-color:yellow;">단, 클래스 선언 시 사용하는 접근제한자는 public과 default만 사용 가능하다.</mark>_

{% code title="메서드 통해서만 값 변경 가능" %}
```java
// 멤버변수는 private
private String kinds;
private  int hp;

public void setKinds(String kinds){
    this.kinds = kinds;
}

// 메서드는 public
public  void setHp(int hp){
    if(hp > 0){
        this.hp = hp;
    }else{
        this.hp = 0;
    }
}

public String getInfo(){
    return "몬스터의 종류는 " + this.kinds + "이고, 체력은" + this.hp + "입니다.";
}
```
{% endcode %}

## 3️⃣ 추상화(abstraction)

객체를 설계하기 위해서는 복잡한 현실세계를 그대로 반영하기에는 너무 방대하고 복잡하기 때문에&#x20;_<mark style="color:purple;">현실 세계를 프로그램의 목적에 맞게 단순화하는 추상화라는 기법을 적용하게 된다.</mark>_

### 🤔 추상화란?

공통된 부분을 추출하고, 공통되지 않은 부분을 제거한다는 의미를 가지며, 추상화의 목적은 <mark style="background-color:yellow;">**유연성**</mark>을 확보하기 위함이다.\
유연성 확보는 여러 곳에 적용될 수 있는 유연한 객체를 의미하며, 즉 _<mark style="color:red;">재사용성이 높아질 수 있게 한다는 의미</mark>_&#xC774;다.\
객체의 재사용성이 증가하면 중복 작성되는 코드를 줄일 수 있으며, <mark style="background-color:green;">오류 발생 가능성을 감소시키고 유지보수성을 증가시킨다.</mark>



### 추상화 기법을 활용한 객체 설계

정리 다하고 할 예정\~



## 4️⃣ DTO(Data Tranfer Object)

_캡슐화의 원칙에는 일부 어&#xAE0B;_&#xB098;긴 하지만 다른 목적을 가진 클래스와 객체를 추상화 하는 기법이 있다.\
<mark style="background-color:green;">**행위 위주가 아닌 데이터를 하나로 뭉치기 쉬운 객체(Data Transfer Object)**</mark>의 경우이다.\
이러한 객체를 설계할 때는 행위가 아닌 _<mark style="color:red;">데이터가 위주</mark>_&#xC774;며, <mark style="background-color:yellow;">캡슐화의 원칙을 준수</mark>하여\
<mark style="background-color:yellow;">모든 필드를 private로 직접 접근을 막</mark>고, 각 <mark style="background-color:yellow;">필드값을 변경하거나 반환하는 메소드를 세트로 미리 작성</mark>해둔다.\
어떤것을 쓸 줄 모르니 미리 다 준비해두는 종합선물세트 같은 개념이다.\
&#xNAN;_<mark style="color:purple;">private 필드와 필드값을 수정하는 설정자(setter), 필드에 접근하는 접근자(getter)들로 구성된다.</mark>_\
<mark style="color:green;">// 주로 계층간 데이터를 주고 받을 목적으로 사용한다.</mark>

### 1. 필드 구성하기

취급하려고 하는 정보를 고려해서 필드를 우선 작성  해 볼수있다.\
주로 화면(UI) 혹은 데이터베이스 테이블을 기준으로 한다.\
&#xNAN;_<mark style="color:purple;">객체가 가지는 속성(필드))를 추출하는 과정 또한 추상화라고 볼 수 있다.</mark>_

<mark style="color:red;background-color:yellow;">DTO클래스를 만들기 위해서는</mark> <mark style="color:red;background-color:yellow;"></mark><mark style="color:red;background-color:yellow;">**모든 필드**</mark><mark style="color:red;background-color:yellow;">를</mark> <mark style="color:red;background-color:yellow;"></mark><mark style="color:red;background-color:yellow;">**private**</mark><mark style="color:red;background-color:yellow;">로 만들어야한다.</mark>

{% code title="✅ Member DTO field" %}
```java
private int number;
private String name;
private int age;
private char gender;
private double height;
private double weight;
private boolean isActivated; // 회원탈퇴여부(활성화 여부)
```
{% endcode %}

이렇게 필드만 만들고 나면 <mark style="color:orange;">**private로 접근이 제한**</mark>되었기 때문에 _<mark style="color:orange;">각 영역에 접근을 할 수 없다.</mark>_\


<mark style="color:red;background-color:yellow;">public으로 접근을 허용하는 설정자/접근자를 이용</mark>해 필드에 <mark style="background-color:yellow;">**간접적으로 접근**</mark>할 수 있도록  해야한다.

### 2. 설정자/접근자 구성하기

설정자(setter)/접근자(getter)의 경우 실무에서 암묵적으로 통용되는 작성 규칙이 존재한다.

#### 설정자(setter)작성 규칙

필드값을 변경할 묵적의 매개변수를 변경하려는 필드와 같은 자료형으로 선언하고\
호출 당시 전달되는 매개변수의 값을 이용하여 필드의 값을 변경한다.

{% code title="⭐ [표현식 ]" %}
```java
public void set필드명(매개변수){
   필드 = 매개변수;
 }
```
{% endcode %}

{% code title="⭐[ 작성 예시 ]" %}
```java
public void setName(String name){
     this.name = name;
   }
```
{% endcode %}

#### 접근자(getter)작성 규칙

필드의 값을 반환받을 목적의 메소드 집합을 의미한다.\
각 접근자는 하나의 필드에만 접근하도록 한다.\
필드에 접근해서 기록된 값을 return을 이용하여 반환하며, 이 때 반환타입은 반환하려는 값의 자료형과 일치시킨다.

{% code title="⭐ [표현식]" %}
```java
public 반환형 get필드명(){
      return 반환값;
 }
```
{% endcode %}

{% code title="⭐ [작성 예시]" %}
```java
public void getName(){
      return this.name;
}
```
{% endcode %}

{% code title="✅ 예시 몇개만..!" %}
```java
public void setNumber(int number){
    this.number = number;
}

public void setName(String name){
    this.name = name;
}

public  void setAge(int age){
    this.age = age;
}

/*boolean의 접근자는 get으로 시작하지 않고 is로 시작하는 것이 일반적인 관례이다.*/
public boolean isActivated(){
    return isActivated;
}
```
{% endcode %}

## 5️⃣ 생성자

### 🤔  생성자란?

인스턴스를 생성할 때 초기 수행할 명령이 있는 경우 미리 작성해두고, _<mark style="color:purple;">인스턴스를 생성할 때 호출</mark>_&#xB41C;다.

\
생성자 함수에 <mark style="color:green;">매개변수가 없는 생성자</mark>를 <mark style="background-color:green;">**기본생성자(default constructor**</mark>)라고 하며,&#x20;기본생성자는 <mark style="color:red;background-color:yellow;">compiler에 의해 자동으로 추가</mark>되기 때문에 지금까지 명시적으로 작성하지 않고 사용할 수 있었다.\
&#xNAN;_&#xAE30;본생성자를 이용해 인스턴스를 생&#xC131;_&#xD558;게 되면 자바에서는 _자료형별 초기값을 이용해 필드를 초기화_ 한다.

{% code title="✅ 기본 생성자 호출" %}
```java
User user1 = new User();
System.out.println(user1.getInfomation());
```
{% endcode %}

\
필드의 초기값을 사용자가 원하는대로 설정하고 싶을 경우 <mark style="color:red;background-color:yellow;">생성자의 호출 시 인자로 값을 전달하여 호출</mark>할 수 있다.&#x20;이러한 <mark style="color:green;">인자를 받아 필드를 초기화</mark> 할 목적의 생성자를 <mark style="background-color:green;">**매개변수 있는 생성자**</mark>라고 한다.

{% code title="✅ 매개변수 있는 생성자 호출" %}
```java
// 일부만 초기화 되므로,
// 아래 생성자로 인해 초기화 되지 않은 값을 접근하려고 하면
// 오류가 날 수 있다.
User user2 = new User("user01", "pass01", "홍길동");
System.out.println(user2.getInfomation());
```
{% endcode %}

‼️하지만 _<mark style="color:red;">매개변수 있는 생성자가 한 개라도 존재하는 경우 compiler 기본 생성자를 자동으로 추가해주지 않는다.</mark>_\
✨ 매개변수 있는 생성자는 주로 <mark style="background-color:yellow;">**인스턴스 생성 시점**</mark><mark style="background-color:yellow;">에</mark> <mark style="background-color:yellow;"></mark><mark style="background-color:yellow;">**필드의 값**</mark><mark style="background-color:yellow;">을 사용자가</mark> <mark style="background-color:yellow;"></mark><mark style="background-color:yellow;">**원하는 대로 초기화**</mark> <mark style="background-color:yellow;"></mark><mark style="background-color:yellow;">할 목적으로 사용</mark>한다.

{% code title="✅ 모든 필드 초기화 생성자 호출" %}
```java
User user3 = new User("user02", "pass02", "이순신", new java.util.Date()); // java.util.Date를 통해서 현재 날짜로 초기화.
System.out.println(user3.getInfomation());
```
{% endcode %}

### 1. 생성자의 작성 위치

작성 위치는 문법상으로는 **클래스 내부**에 작성하면 되지만,\
통상적으로 **필드 선언부와 메소드 선언부 사이**에 작성하는 것이 관례이다.

### 2. 생성자의 사용 목적

1. <mark style="color:purple;">**인스턴스 생성 시점**</mark>에 수행할 명령이 있는 경우 사용한다.
2. 매개변수 있는 생성자의 경우 매개변수로 전달받은 값으로 **필드를 초기화** 하며 **인스턴스를 생성할 목적**으로 주로 사용된다.
3. 작성한 생성자 외에는 인스턴스를 생성하는 방법을 제공하지 않는다는 의미를 가진다.
4. 따라서, _<mark style="color:purple;">인스턴스를 생성하는 방법을 제한하기 위한 용도</mark>_&#xB85C; 사용할 수도 있다. <mark style="background-color:green;">(초기값 전달 강제화)</mark>

### 3. 생성자 작성 방법

{% code title="⭐ 표현식" %}
```java
접근제한자 클래스명(매개변수){
    인스턴스 생성 시점에 수행할 명령 기술(주로 필드를 초기화)
    this.필드명 = 매개변수; //설정자(setter) 여러 개의 기능을 한 번의 호출로 수행할 수 있다.
}
```
{% endcode %}

### 4. 생성자 작성 시 주의할 점

1. 생성자 메소드는 반드시 <mark style="color:red;background-color:yellow;">클래스의 이름과 동일</mark>해야 한다. (대/소문자까지 같아야함)
2. 생성자 메소드는 <mark style="color:red;background-color:yellow;">반환형을 작성하지 않는다</mark>. ( 작성하는 경우 생성자가 아닌 메소드로 인식한다. )

### 5. 생성자 사용예시

{% code title="1️⃣ 기본 생성자" %}
```java
public User(){
    /* 수행할 내용이 아무 것도 존재하지 않는다. */
    System.out.println("User 클래스의 기본 생성자 호출함...");
}

// 동일한 이름의 생성자 혹은 메소드를 한 클래스 안에서 작성하는 것은 불가능하다.
// public User(){자
```
{% endcode %}

{% code title="2️⃣ 매개변수 있는 생성자" %}
```java
/* 초기화할 필드가 여러개 인 경우, 초기화 하고 싶은 필드의 갯수별로 생성자를 여러 개 준비해둘 수 있다. */
/* id, pwd, name의 초기화를 담당할 생성자 */
public User(String id, String pwd, String name){

    /*  매개변수 있는 생성자의 주 목적은 인스턴스 생성 시점에 매개변수로 전달 받은 값을 이용해서 필드를 초기화한다. */
    this.id = id;
    this.pwd = pwd;
    this.name = name;

    System.out.println("User 클래스의 id, pwd, name을 초기화하는 생성자 호출함...");
}
```
{% endcode %}

{% code title="3️⃣ 모든 필드 초기화 생성자" %}
```java
public User(String id, String pwd, String name, java.util.Date enrollDate){

        /* 매개변수로 전달 받은 값을 이용해 모든 필드를 초기화한다. */
        /* 3-1. 각 필드에 접근하여 초기화 */
//        this.id = id;
//        this.pwd = pwd;
//        this.name = name;
//        this.enrollDate = enrollDate;

        /* 3-2. 사전에 작성되어 있는 다른 생성자 함수를 이용하여 초기화 */
        /* this() : 동일 클래스 내에 작성한 다른 생성자 메소드를 호출하는 구문이다.
        *           가장 첫 줄에 선언해야 한다.
        * */
        this(id, pwd, name); // 미리 작성한 세 개의 필드를 초기화하는 생성자로 매개변수로 받은 값을 전달
        this.enrollDate = enrollDate;

        System.out.println("User 클래스의 모든 필드를 초기화하는 생성자 호출함...");
    }
```
{% endcode %}



### 💡  생성자를 이용한 초기화 VS 설정자를 위한 초기화

#### 생성자를 이용한 초기화

**장점** : setter 메소드를 여러 번 호출해서 사용하지 않고 단 <mark style="color:red;">한번의 호출로 인스턴스를 생성 및 초기화</mark> 할 수 있다.\
**단점** : 필드를 초기화할 _<mark style="color:red;">매개변수의 갯수를 경우의 수 별로 모두 만들어둬야 한다.</mark>_\
호출 시 인자가 많아지는 경우 어떠한 값이 어떤 필드를 의미하는지 한 눈으로 보기 힘들다.

```java
UserDTO user1 = new UserDTO("ohgiraffers", "ohgiraffers","ohgiraffers", new java.util.Date());
System.out.println(user1.getInformation());
```

#### 설정자를 이용한 초기화

**장점** : 필드를 초기화하는 <mark style="color:red;">각각의 값들이 어떤 필드를 초기화하는지 명확하게 볼 수 있다.</mark>\
**단점** : 하나의 인스턴스를 생성할 때 <mark style="color:red;">한 번의 호출로 끝나지 않는다.</mark>

```java
UserDTO user2 = new UserDTO();
user2.setId("ohgiraffers");
user2.setPwd("ohgiraffers");
user2.setName("ohgiraffers");
user2.setEnrollDate(new java.util.Date());

System.out.println(user2.getEnrollDate());
```
