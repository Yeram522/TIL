---
description: 간단한 퀴즈를 보았고, 답변 내용을 AI에게 피드백 요청했습니다.
---

# 7/25 현업개발자 멘토링

## CS 기초 퀴즈 복습 자료

### 1. CS 기초

#### Q1. 프로그램이 동작하기 위한 가장 중요한 컴퓨터의 물리적 자원 3가지를 기술해보세요.

**작성한 답안:** CPU, RAM, 영구적으로 저장하는 기억장치들

**모범답안:**

* **CPU (Central Processing Unit)**: 명령어를 해석하고 실행하는 중앙처리장치
* **메모리 (RAM)**: 프로그램과 데이터를 임시 저장하는 주기억장치
* **저장장치 (Storage)**: 데이터를 영구적으로 보관하는 보조기억장치 (HDD, SSD 등)

**평가:** ✅ 정답! 핵심 요소를 모두 포함했습니다.

**면접 대응:** "프로그램 실행에 필요한 3대 자원은 CPU, 메모리, 저장장치입니다. CPU는 연산 처리를, 메모리는 실행 중인 프로그램과 데이터 저장을, 저장장치는 영구 데이터 보관을 담당합니다."

***

#### Q2. 운영체제의 역할을 설명해보세요.

**작성한 답안:** 사용자와 커널 수준의 하드웨어 컨트롤을 중재해주는 시스템

**모범답안:**

* **하드웨어 자원 관리**: CPU, 메모리, 입출력장치 등의 효율적 할당
* **프로세스 관리**: 프로그램 실행, 스케줄링, 동기화
* **메모리 관리**: 물리/가상 메모리 할당 및 보호
* **파일 시스템 관리**: 데이터 저장 및 접근 제어
* **사용자 인터페이스 제공**: 시스템 호출을 통한 하드웨어 접근

**평가:** ⚠️ 기본 개념은 맞지만 구체적인 역할들이 부족합니다.

**추가 키워드:** 자원 관리, 프로세스 스케줄링, 메모리 관리, 파일 시스템, 보안

**면접 대응:** "운영체제는 하드웨어와 사용자 사이의 인터페이스 역할을 합니다. 주요 기능은 자원 관리, 프로세스 관리, 메모리 관리, 파일 시스템 관리, 그리고 보안 기능입니다."

***

#### Q3. 프로세스와 스레드의 개념과 차이점에 대해서 설명해보세요.

**작성한 답안:** 프로세스는 작업의 단위, 스레드는 프로세스 내부에서 작동하는 더 작은 단위. 프로세스끼리는 메모리 공유를 하지 않지만 같은 프로세스 내부에 있는 스레드는 메모리 공유가 가능하다.

**모범답안:**

* **프로세스**: 실행 중인 프로그램의 인스턴스, 독립적인 메모리 공간 보유
* **스레드**: 프로세스 내에서 실행되는 실행 단위, 같은 프로세스의 스레드들은 메모리 공간 공유
* **차이점**:
  * 메모리: 프로세스는 독립적, 스레드는 공유
  * 생성 비용: 프로세스가 더 큰 오버헤드
  * 통신: 프로세스는 IPC 필요, 스레드는 직접 통신 가능

**평가:** ✅ 잘 작성했습니다!

**추가 키워드:** 컨텍스트 스위칭, IPC, 동시성, 병렬성

**면접 대응:** "프로세스는 독립적인 메모리 공간을 가진 실행 단위이고, 스레드는 프로세스 내에서 메모리를 공유하는 실행 단위입니다. 스레드는 생성 비용이 적고 통신이 쉽지만, 동기화 문제를 고려해야 합니다."

***

#### Q4. 멀티스레드 환경에서 발생할 수 있는 주요 문제점인 '경쟁 조건'과 '교착 상태'를 각각 설명하고, 해결 방법을 설명해보세요.

**작성한 답안:** 경쟁 조건: 공유 자원을 여러 스레드가 동시에 접근하면 해당 자원에 대해 결과를 알 수 없게 된다.

* 해결 방법: 공유 자원에 접근 할 때는 공유 자원에 대해 락을 하고, 해당 공유 자원을 대기하는 스레드에 대해 대기 풀에서 기다리게 한다.

교착 상태: 여러개의 스레드가 서로가 가지고 있는 자원을 기다리는 상황이 되어 무한히 대기 상태가 되는 상태.

* 교착 상태가 발생하려면 여러 조건이 있는데 그 조건 중 하나라도 해당하지 않게 해서 교착 상태를 방지한다.

**모범답안:**

* **경쟁 조건 (Race Condition)**: 여러 스레드가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과가 달라지는 상황
  * 해결방법: Mutex, Semaphore, Monitor 등의 동기화 기법 사용
* **교착 상태 (Deadlock)**: 두 개 이상의 프로세스/스레드가 서로 상대방의 자원을 기다리며 무한 대기하는 상태
  * 발생 조건: 상호 배제, 점유와 대기, 비선점, 순환 대기
  * 해결방법: 예방, 회피, 탐지 및 회복

**평가:** ✅ 개념은 잘 이해했지만, 교착상태의 구체적인 조건과 해결방법이 부족합니다.

**추가 키워드:** Mutex, Semaphore, Monitor, Banker's Algorithm, 자원 할당 그래프

**면접 대응:** "경쟁 조건은 공유 자원의 동시 접근으로 인한 예측 불가능한 결과를 말하며, 동기화 기법으로 해결합니다. 교착상태는 순환 대기 상황으로, 4가지 발생 조건 중 하나를 제거하여 예방할 수 있습니다."

***

#### Q5. 동기와 비동기에 대해서 설명해보세요.

**작성한 답안:** 동기: 작업이 순차적으로 진행 되는 것. 하나의 작업이 끝나는 것을 기다리고 다음 작업을 실행. 비동기: 작업이 별도의 스레드에서 진행되고, 메인 스레드는 계속 다음 작업을 진행한다.

**모범답안:**

* **동기 (Synchronous)**: 작업 요청 후 완료될 때까지 대기하는 방식
  * 장점: 구현이 간단, 순서 보장
  * 단점: 대기 시간으로 인한 성능 저하
* **비동기 (Asynchronous)**: 작업 요청 후 완료를 기다리지 않고 다른 작업을 계속 수행하는 방식
  * 장점: 효율적인 자원 활용, 높은 처리량
  * 단점: 복잡한 구현, 순서 제어의 어려움

**평가:** ✅ 기본 개념은 정확합니다!

**추가 키워드:** 블로킹/논블로킹, 콜백, Promise, Future, 이벤트 루프

**면접 대응:** "동기는 작업 완료를 기다리는 방식으로 순서가 보장되지만 성능이 떨어지고, 비동기는 대기하지 않고 진행하여 성능은 좋지만 복잡도가 증가합니다."

***

### 2. Java 기초

#### Q1. Java의 기본 데이터 타입과 참조 데이터 타입의 차이점을 메모리 저장 방식과 할당 관점에서 설명하고, 각 타입의 대표적인 예시를 들어보세요.

**작성한 답안:** 기본 데이터 타입은 값을 저장하지만. 참조 데이터 타입은 객체에 대한 주소 값을 저장한다. 따라서 참조 데이터 타입을 사용하면 힙에 저장된 주소 값에 접근하여 값을 받아오기 때문에 null pointer Exception이 일어날 수 있다.

**모범답안:**

* **기본 데이터 타입 (Primitive Type)**:
  * 스택 메모리에 실제 값 저장
  * 예시: int, char, boolean, double, byte, short, long, float
  * 크기가 고정되어 있음
* **참조 데이터 타입 (Reference Type)**:
  * 스택에는 주소값, 힙에는 실제 객체 저장
  * 예시: String, Array, Class, Interface
  * 동적 메모리 할당, null 가능

**평가:** ✅ 좋은 답안이지만 스택/힙 메모리 구분과 구체적 예시가 부족합니다.

**추가 키워드:** 스택 메모리, 힙 메모리, 가비지 컬렉션, Wrapper 클래스

**면접 대응:** "기본 타입은 스택에 값을 직접 저장하고, 참조 타입은 스택에 주소값을, 힙에 실제 객체를 저장합니다. 예를 들어 int는 기본 타입, String은 참조 타입입니다."

***

#### Q2. 오버로딩과 오버라이딩에 대해서 설명해보세요.

**작성한 답안:** 오버로딩: 부모 객체의 메서드를 재정의 하는것 오버라이딩: 메서드의 이름은 같지만 메서드의 매개변수 타입이 다른 메서드로 만드는 것

**모범답안:**

* **오버로딩 (Overloading)**: 같은 클래스 내에서 메서드 이름은 같지만 매개변수가 다른 메서드를 여러 개 정의
  * 컴파일 타임에 결정 (정적 바인딩)
* **오버라이딩 (Overriding)**: 상속 관계에서 부모 클래스의 메서드를 자식 클래스에서 재정의
  * 런타임에 결정 (동적 바인딩)

**평가:** ❌ 개념이 바뀌어 있습니다. 다시 학습이 필요합니다.

**추가 키워드:** 다형성, 정적/동적 바인딩, @Override 어노테이션

**면접 대응:** "오버로딩은 같은 이름의 메서드를 매개변수를 다르게 해서 여러 개 만드는 것이고, 오버라이딩은 상속받은 부모 메서드를 자식에서 재정의하는 것입니다."

***

#### Q3. Java 클래스의 생성자의 주요 목적은 무엇이며 어떻게 호출되는지 설명해보세요.

**작성한 답안:** 생성자는 new 키워드를 통해 객체를 생성할 때 자동적으로 호출이 된다. 주로 객체의 초기화를 담당한다.

**모범답안:**

* **목적**: 객체 생성 시 초기화 작업 수행
* **특징**:
  * 클래스명과 동일한 이름
  * 반환 타입이 없음
  * new 키워드로 객체 생성 시 자동 호출
  * 오버로딩 가능
  * 기본 생성자 자동 제공 (다른 생성자가 없을 때)

**평가:** ✅ 정확한 답안입니다!

**추가 키워드:** 기본 생성자, 매개변수 생성자, this(), super()

**면접 대응:** "생성자는 객체 초기화를 담당하며, new 키워드로 객체 생성 시 자동 호출됩니다. 클래스명과 같고 반환 타입이 없으며, 오버로딩이 가능합니다."

***

#### Q4. Java의 접근 제어자 종류를 기술하고, 각각 어떤 역할을 하는지 설명해보세요.

**작성한 답안:** private : 정의된 클래서 내에서만 사용 가능 protected : 상속된 자식들까지 사용 가능 default : 같은 패키지 내에서 사용 가능 public: 모두 사용 가능

**모범답안:**

* **private**: 같은 클래스 내에서만 접근 가능
* **default (package-private)**: 같은 패키지 내에서만 접근 가능
* **protected**: 같은 패키지 또는 상속받은 하위 클래스에서 접근 가능
* **public**: 모든 곳에서 접근 가능

**평가:** ✅ 완벽한 답안입니다!

**추가 키워드:** 캡슐화, 정보 은닉, 접근 범위

**면접 대응:** "접근 제어자는 private(클래스 내), default(패키지 내), protected(패키지+상속), public(모든 곳) 순으로 접근 범위가 넓어집니다."

***

#### Q5. Java의 배열과 연결리스트의 차이점에 대해서 설명해보세요.

**작성한 답안:** 배열은 연속적인 메모리에 저장되고 연결 리스트는 비 연속적인 메모리에 저장된다. 배열은 인덱스로 접근하기 때문에 O(1)의 시간복잡도로 접근이 가능하지만, 연결 리스트는 인덱스로 접근이 불가하고 포인터로 순회해서 노드에 접근 해야 하므로 개별적인 값의 접근과 수정을 하기에는 O(n)의 시간복잡도가 걸릴 수 있다. 배열은 한번 크기를 정하면 크기를 늘리기 위해서는 O(n)의 시간복잡도가 걸린다. 연결리스트는 크기를 자유롭게 조정할 수 있고 O(1)의 시간복잡도 밖에 걸리지 않는다.

**모범답안:**

* **배열 (Array)**:
  * 연속된 메모리 공간에 저장
  * 인덱스를 통한 랜덤 액세스 O(1)
  * 고정 크기
  * 삽입/삭제 시 요소 이동 필요 O(n)
* **연결리스트 (LinkedList)**:
  * 비연속적 메모리에 노드로 저장
  * 순차 접근만 가능 O(n)
  * 동적 크기 조정 가능
  * 삽입/삭제가 효율적 O(1) (위치를 알고 있을 때)

**평가:** ✅ 매우 정확하고 상세한 답안입니다!

**추가 키워드:** 캐시 지역성, 메모리 오버헤드, ArrayList vs LinkedList

**면접 대응:** "배열은 연속 메모리로 인덱스 접근이 빠르지만 크기가 고정이고, 연결리스트는 동적 크기 조정이 가능하지만 순차 접근만 됩니다."

***

#### Q6. Java의 예외 처리 메커니즘에서 try-catch-finally 블록의 역할과, checked exception, unchecked exception의 차이점에 대해 설명해보세요.

**작성한 답안:** try 블록에서 예외 발생시 catch 블록으로 이동하여 어떤 예외가 발생하는지 알 수 있다.

**모범답안:**

* **try-catch-finally**:
  * try: 예외가 발생할 수 있는 코드 블록
  * catch: 예외 처리 코드 블록
  * finally: 예외 발생 여부와 관계없이 항상 실행되는 블록
* **Checked Exception**: 컴파일 시점에 체크되는 예외 (IOException, SQLException)
* **Unchecked Exception**: 런타임에 발생하는 예외 (RuntimeException의 하위 클래스)

**평가:** ⚠️ try-catch의 기본 개념만 언급하고 finally와 예외 종류에 대한 설명이 누락되었습니다.

**추가 키워드:** RuntimeException, Error, throws, 예외 전파

**면접 대응:** "try는 예외 발생 가능 코드, catch는 예외 처리, finally는 항상 실행되는 블록입니다. Checked Exception은 컴파일 시 처리 강제, Unchecked Exception은 런타임 예외입니다."

***

#### Q7. Java 언어의 가장 큰 특징은 무엇이라고 생각하나요? 그리고 JVM은 어떤 것이며 JVM을 통해서 Java 클래스가 실행되는 과정을 설명하고, 컴퓨터 자원(특히 메모리)을 어떻게 관리하는지 설명하세요.

**작성한 답안:** Java를 컴파일하고 실행하는 가상 머신.

**모범답안:**

* **Java의 특징**: "Write Once, Run Anywhere" - 플랫폼 독립성
* **JVM (Java Virtual Machine)**: Java 바이트코드를 실행하는 가상 머신
* **실행 과정**:
  1. .java → javac → .class (바이트코드)
  2. JVM이 바이트코드 로드
  3. 클래스 로더가 메모리에 적재
  4. 바이트코드 검증
  5. JIT 컴파일러가 네이티브 코드로 변환
  6. 실행
* **메모리 관리**:
  * Heap: 객체 저장 공간
  * Stack: 메서드 호출과 지역변수
  * Method Area: 클래스 정보, 상수풀
  * 가비지 컬렉션을 통한 자동 메모리 관리

**평가:** ❌ 너무 간단한 답변입니다. JVM의 역할과 메모리 관리에 대한 이해가 부족합니다.

**추가 키워드:** 바이트코드, JIT 컴파일러, 클래스 로더, 가비지 컬렉션, Heap/Stack/Method Area

**면접 대응:** "Java의 가장 큰 특징은 플랫폼 독립성입니다. JVM은 바이트코드를 실행하는 가상머신으로, 클래스 로딩, JIT 컴파일, 가비지 컬렉션을 통해 메모리를 자동 관리합니다."

***

### 3. OOP (객체 지향 프로그래밍)

#### Q1. 클래스, 객체, 인스턴스에 대해서 설명해보세요.

**작성한 답안:** 클래스는 여러 객체의 집합 객체는 하나의 자원 및 단위 인스턴스는 잠깐 사용되는 일시적인 변수?

**모범답안:**

* **클래스 (Class)**: 객체를 만들기 위한 설계도나 템플릿
* **객체 (Object)**: 클래스를 기반으로 생성된 실체, 속성과 행동을 가짐
* **인스턴스 (Instance)**: 특정 클래스로부터 생성된 객체, 메모리에 할당된 구체적인 실체

**평가:** ❌ 개념에 대한 이해가 부족합니다. 다시 학습이 필요합니다.

**추가 키워드:** 설계도, 실체화, 메모리 할당, 생성자

**면접 대응:** "클래스는 객체를 만들기 위한 설계도이고, 객체는 클래스를 바탕으로 만들어진 실체입니다. 인스턴스는 메모리에 할당된 구체적인 객체를 의미합니다."

***

#### Q2. 객체 지향 프로그래밍의 4가지 주요 원칙 중 '캡슐화'의 개념을 설명하고, Java 코드 예시를 통해 어떻게 구현되는지 보여주세요.

**작성한 답안:** 캡슐화는 내부의 객체를 외부에서 함부로 수정할 수 없게 보호하는 것.

```java
private String name;
public String getName(){
    return this.name;
}
```

**모범답안:**

* **캡슐화**: 데이터와 메서드를 하나로 묶고, 외부에서의 직접 접근을 제한하여 데이터 무결성을 보장
* **구현 방법**:
  * 필드를 private로 선언
  * public getter/setter 메서드 제공
  * 필요시 유효성 검증 로직 추가

```java
public class Person {
    private String name;
    private int age;
    
    public String getName() {
        return name;
    }
    
    public void setAge(int age) {
        if (age > 0) {
            this.age = age;
        }
    }
}
```

**평가:** ✅ 기본 개념과 예시는 맞지만, setter 예시와 유효성 검증이 부족합니다.

**추가 키워드:** 정보 은닉, 데이터 무결성, getter/setter, 유효성 검증

**면접 대응:** "캡슐화는 데이터와 메서드를 묶고 외부 접근을 제한하는 것입니다. private 필드와 public 메서드를 통해 데이터 무결성을 보장합니다."

***

#### Q3. '인터페이스'와 '추상 클래스'는 객체 지향 설계에서 모두 추상화를 제공하지만, 그 목적과 사용법에 차이가 있습니다. 두 요소의 주요 차이점을 설명하고, 각각 어떤 상황에 더 적합한지 예시를 들어서 설명해보세요.

**작성한 답안:** 인터페이스는 함수의 정의만 해두고 실체는 구현하지 않는 반면 추상 클래스는 이미 실체가 구현되어있다. 상속 받을 클래스가 각각 실체에 대한 구현이 다르다면 인터페이스, 추상 클래스의 메서드를 상속받은 클래스가 사용하게된다면 추상 클래스를 사용하는게 맞다고 생각합니다.

**모범답안:**

* **인터페이스 (Interface)**:
  * 모든 메서드가 추상 메서드 (Java 8부터 default, static 메서드 가능)
  * 다중 상속 지원
  * 구현을 강제하는 계약
  * 예시: Drawable 인터페이스 (Circle, Rectangle이 각자 다르게 구현)
* **추상 클래스 (Abstract Class)**:
  * 일부 메서드는 구현, 일부는 추상 메서드
  * 단일 상속만 가능
  * 공통 기능을 제공하면서 일부만 하위 클래스에서 구현
  * 예시: Animal 추상 클래스 (공통 메서드 + 추상 메서드)

**평가:** ⚠️ 기본 개념은 이해했지만, 다중 상속과 구체적인 사용 시나리오 설명이 부족합니다.

**추가 키워드:** 다중 상속, default 메서드, 템플릿 메서드 패턴, 계약

**면접 대응:** "인터페이스는 구현을 강제하는 계약으로 다중 상속이 가능하고, 추상 클래스는 공통 기능을 제공하면서 일부만 구현을 강제합니다."

***

### 4. Database

#### Q1. INNER JOIN과 LEFT JOIN에 대해서 비교해서 설명해보세요.

**작성한 답안:** INNER JOIN은 교집합 LEFT JOIN은 FROM 테이블에 있는 값만 조인

**모범답안:**

* **INNER JOIN**: 두 테이블에서 조인 조건을 만족하는 행만 반환 (교집합)
* **LEFT JOIN (LEFT OUTER JOIN)**: 왼쪽 테이블의 모든 행과 오른쪽 테이블에서 조건에 맞는 행을 반환, 매치되지 않으면 NULL

```sql
-- INNER JOIN
SELECT * FROM A INNER JOIN B ON A.id = B.id;

-- LEFT JOIN  
SELECT * FROM A LEFT JOIN B ON A.id = B.id;
```

**평가:** ✅ 기본 개념은 정확하지만, SQL 예시가 부족합니다.

**추가 키워드:** OUTER JOIN, RIGHT JOIN, FULL OUTER JOIN, NULL

**면접 대응:** "INNER JOIN은 양쪽 테이블에 모두 존재하는 데이터만 반환하고, LEFT JOIN은 왼쪽 테이블의 모든 데이터와 오른쪽 테이블에서 매칭되는 데이터를 반환합니다."

***

#### Q2. SQL에서 WHERE 절과 HAVING 절의 차이점을 설명하고, 각 절이 사용되는 상황에 대한 간단한 예시를 들어보세요.

**작성한 답안:** WHERE 은 조건, HAVING은 GROUP 함수를 쓸 때의 조건

**모범답안:**

* **WHERE 절**: 개별 행에 대한 조건을 지정, GROUP BY 이전에 실행
* **HAVING 절**: 그룹화된 결과에 대한 조건을 지정, GROUP BY 이후에 실행

```sql
-- WHERE 예시
SELECT * FROM employees WHERE salary > 50000;

-- HAVING 예시  
SELECT department, AVG(salary) 
FROM employees 
GROUP BY department 
HAVING AVG(salary) > 60000;
```

**평가:** ✅ 기본 개념은 맞지만, 실행 순서와 구체적인 예시가 부족합니다.

**추가 키워드:** 집계 함수, 실행 순서, 그룹화

**면접 대응:** "WHERE는 개별 행 필터링에 사용되고, HAVING은 GROUP BY로 그룹화된 결과를 필터링할 때 사용됩니다. 실행 순서상 WHERE가 먼저 실행됩니다."

***

#### Q3. 트랜잭션에 대해서 설명해보세요.

**작성한 답안:** 데이터의 무결성을 지키기 위한 것. All or Nothing Transaction 대상이 아닌 다른 것들은 전과 이후의 상태가 같아야한다. 트랜잭션이 실패했다면 원복되어야한다.

**모범답안:**

* **트랜잭션**: 데이터베이스에서 하나의 논리적 작업 단위
* **ACID 속성**:
  * **Atomicity (원자성)**: All or Nothing, 모두 성공하거나 모두 실패
  * **Consistency (일관성)**: 트랜잭션 전후 데이터 무결성 유지
  * **Isolation (고립성)**: 동시 실행되는 트랜잭션들이 서로 영향을 주지 않음
  * **Durability (지속성)**: 완료된 트랜잭션의 결과는 영구적으로 저장

**평가:** ✅ 기본 개념은 이해했지만, ACID 용어와 고립성, 지속성에 대한 설명이 부족합니다.

**추가 키워드:** ACID, 커밋, 롤백, 동시성 제어, 락

**면접 대응:** "트랜잭션은 하나의 논리적 작업 단위로, ACID 속성(원자성, 일관성, 고립성, 지속성)을 보장하여 데이터 무결성을 유지합니다."

***

#### Q4. DB의 Index에 대해서 설명해보세요.

**작성한 답안:** INDEX는 key:value의 형태로 별도의 메모리에 저장된다. INDEX로 설정된 속성은 키밸류 형태로 저장되기 때문에 접근시 O(1)의 시간복잡도를 보장한다. 하지만 INDEX도 결국 어딘가에 저장되는 것이기 때문에 시간복잡도와 반비례하여 공간복잡도가 생길 수 있다.

**모범답안:**

* **인덱스**: 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
* **특징**:
  * 일반적으로 B-Tree 구조 사용 (O(log n))
  * 별도의 저장 공간 필요
  * 조회 성능 향상, 삽입/수정/삭제 성능 저하
* **종류**:
  * 클러스터드 인덱스: 데이터와 함께 정렬되어 저장
  * 논클러스터드 인덱스: 별도의 구조로 저장
* **주의사항**: 과도한 인덱스는 오히려 성능 저하 초래

**평가:** ⚠️ 시간복잡도가 O(1)이 아니라 일반적으로 O(log n)입니다. B-Tree 구조에 대한 이해가 부족합니다.

**추가 키워드:** B-Tree, 클러스터드/논클러스터드, 복합 인덱스, 카디널리티

**면접 대응:** "인덱스는 검색 속도 향상을 위한 B-Tree 구조의 자료구조입니다. 조회는 빨라지지만 삽입/수정/삭제 시 오버헤드가 발생합니다."

***

### 5. Spring

#### Q1. Spring Framework에서 의존성을 주입받는 대표적인 세 가지 방법에 대해 설명하고, 각 방법의 특징을 설명해보세요.

**작성한 답안:** @Bean으로 등록하고 @AutoWire을 사용해 Spring이 해당 클래스를 관리하게 하여 생성자가 호출될 때 자동으로 주입되게한다. LomBook을 이용해 의존성을 주입받을 객체를 final로 설정한 후 @RequiredArgument? 어노테이션을 이용해서 주입받는다.

**모범답안:**

* **생성자 주입 (Constructor Injection)**:
  * 생성자를 통해 의존성 주입
  * 불변성 보장, 순환 참조 방지
  * Spring 권장 방식

```java
@Service
public class UserService {
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

* **수정자 주입 (Setter Injection)**:
  * Setter 메서드를 통해 주입
  * 선택적 의존성에 사용

```java
@Service
public class UserService {
    private UserRepository userRepository;
    
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

* **필드 주입 (Field Injection)**:
  * 필드에 직접 주입
  * 테스트 어려움, 권장하지 않음

```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
}
```

**평가:** ⚠️ 기본 개념은 이해했지만, 세 가지 방법을 명확히 구분하지 못했습니다.

**추가 키워드:** @Autowired, @RequiredArgsConstructor, 순환 참조, 불변성

**면접 대응:** "생성자 주입은 불변성을 보장하는 권장 방식이고, 수정자 주입은 선택적 의존성에, 필드 주입은 간단하지만 테스트가 어려워 권장하지 않습니다."

***

#### Q2. Spring Framework에서 빈(Bean)이 무엇인지 설명하고, 객체를 빈으로 등록하는 방법에 대해서 아는대로 적어보세요.

**작성한 답안:** @Bean은 스프링이 관리하는 객체. 1번 답변에서 답변을 한 것 같아서..사실 1번 문제를 제가 제대로 답변했는지 잘 모르겠습니다...

**모범답안:**

* **빈(Bean)**: Spring IoC 컨테이너가 관리하는 객체
* **빈 등록 방법**:
  1. **컴포넌트 스캔**: @Component, @Service, @Repository, @Controller
  2. **Java Config**: @Configuration + @Bean
  3. **XML 설정**: \<bean> 태그 사용

```java
// 1. 컴포넌트 스캔
@Service
public class UserService { }

// 2. Java Config
@Configuration
public class AppConfig {
    @Bean
    public UserService userService() {
        return new UserService();
    }
}
```

**평가:** ⚠️ 빈의 정의는 맞지만, 구체적인 등록 방법들을 충분히 설명하지 못했습니다.

**추가 키워드:** IoC 컨테이너, 컴포넌트 스캔, @Configuration, 싱글톤

**면접 대응:** "빈은 Spring 컨테이너가 관리하는 객체입니다. 컴포넌트 스캔, Java Config의 @Bean, XML 설정으로 등록할 수 있습니다."

***

#### Q3. Spring Framework에서 'IoC'와 'DI'에 대해 설명하고, Spring Framework에서 IoC와 DI를 적용한 근본적인 이유에 대해 본인이 생각한 내용을 적어보세요.

**작성한 답안:** 원래는 개발자가 객체의 생성에 대한 책임을 갖고 있었는데 의존성 역전으로 인해 Spring이 객체의 생성을 관리하게 되면서 객체가 단 하나로(싱글톤)으로 존재할 수 있게 되었다. 어노테이션 종류는 여러가지 있는데 @Service, @Config, @Controller 각각 세부적인 특징이 있고 @Bean은 이 친구들의 상위 어노테이션이라고 볼 수 있다. 따라서 IOC에서 이를 관리하고 있기 때문에 개발자는 객체지향의 원칙을 반강제적으로? 지킬 수 있게 된다고 생각한다.

**모범답안:**

* **IoC (Inversion of Control)**: 제어의 역전, 객체의 생성과 관리를 외부(컨테이너)에서 담당
* **DI (Dependency Injection)**: 의존성 주입, 객체가 필요로 하는 의존성을 외부에서 주입

**적용 이유**:

1. **느슨한 결합**: 객체 간 의존성 감소
2. **테스트 용이성**: Mock 객체 주입 가능
3. **유지보수성**: 설정 변경으로 동작 변경 가능
4. **재사용성**: 컴포넌트의 독립적 사용
5. **관심사 분리**: 비즈니스 로직과 객체 생성 분리

**평가:** ⚠️ IoC와 DI의 기본 개념은 이해했지만, 어노테이션에 대한 이해가 부정확하고 구체적인 장점 설명이 부족합니다.

**추가 키워드:** 제어 역전, 느슨한 결합, 테스트 용이성, SOLID 원칙

**면접 대응:** "IoC는 객체 생성 제어를 컨테이너에 맡기는 것이고, DI는 필요한 의존성을 외부에서 주입하는 것입니다. 이를 통해 느슨한 결합과 테스트 용이성을 얻을 수 있습니다."

***

### 6. JDBC

#### Q1. JDBC가 무엇인가요?

**작성한 답안:** 자바에서 제공하는 데이터베이스를 관리할 수 있게 도와주는 라이브러리?

**모범답안:**

* **JDBC (Java Database Connectivity)**: Java에서 데이터베이스에 접근하기 위한 표준 API
* **특징**:
  * 데이터베이스 독립적인 프로그래밍 가능
  * 드라이버를 통해 다양한 DBMS 지원
  * SQL 실행 및 결과 처리 기능 제공

**평가:** ✅ 기본 개념은 맞지만, API라는 점과 표준화에 대한 언급이 부족합니다.

**추가 키워드:** API, 드라이버, 표준화, DBMS 독립성

**면접 대응:** "JDBC는 Java에서 데이터베이스 접근을 위한 표준 API로, 드라이버를 통해 다양한 DBMS에 독립적으로 접근할 수 있습니다."

***

#### Q2. JDBC API를 사용하여 데이터베이스와 연동할 때, Connection, Statement, ResultSet 객체는 각각 어떤 역할을 하는지 설명해보세요.

**작성한 답안:** Connection DB와의 연결 관리 Statement DB

**모범답안:**

* **Connection**: 데이터베이스와의 연결을 나타내는 객체
  * DB 연결 설정 및 관리
  * 트랜잭션 제어 (commit, rollback)
* **Statement**: SQL 문을 실행하기 위한 객체
  * SQL 쿼리 실행
  * PreparedStatement (매개변수 바인딩), CallableStatement (저장 프로시저) 등의 하위 타입
* **ResultSet**: SELECT 쿼리의 결과를 담고 있는 객체
  * 결과 데이터 탐색 및 추출
  * 커서를 이용한 행 단위 접근

**평가:** ❌ Statement와 ResultSet에 대한 설명이 거의 없습니다.

**추가 키워드:** PreparedStatement, 트랜잭션, 커서, SQL Injection 방지

**면접 대응:** "Connection은 DB 연결 관리, Statement는 SQL 실행, ResultSet은 조회 결과를 담는 객체입니다. PreparedStatement를 사용하면 SQL Injection을 방지할 수 있습니다."

***

### 7. JPA

#### Q1. ORM이 무슨 역할을 하는지 설명해보세요.

**작성한 답안:** 객체 단위의 언어와 관계와 속성으로 이루어진 DB를 연결해주는 것

**모범답안:**

* **ORM (Object-Relational Mapping)**: 객체와 관계형 데이터베이스 간의 데이터 매핑을 자동화하는 기술
* **역할**:
  * 객체를 테이블에 자동 매핑
  * SQL 자동 생성
  * 데이터베이스 독립성 제공
  * 개발 생산성 향상
* **장점**: 개발 속도 향상, 유지보수 용이성
* **단점**: 성능 이슈, 복잡한 쿼리 작성의 어려움

**평가:** ✅ 기본 개념은 이해했지만, 구체적인 장단점과 역할 설명이 부족합니다.

**추가 키워드:** 매핑, SQL 자동 생성, 데이터베이스 독립성, Hibernate

**면접 대응:** "ORM은 객체와 관계형 데이터베이스를 자동으로 매핑해주는 기술로, SQL을 자동 생성하여 개발 생산성을 높여줍니다."

***

#### Q2. JPA의 핵심 개념인 '영속성 컨텍스트'가 무엇이며, 이 컨텍스트 내에서 엔티티의 생명 주기가 어떻게 관리되는지 설명해보세요.

**작성한 답안:** Entity의 변경을 DB의 일관성을 지켜주는 것

**모범답안:**

* **영속성 컨텍스트 (Persistence Context)**: 엔티티를 영구 저장하는 환경, 1차 캐시 역할
* **엔티티 생명주기**:
  1. **비영속 (New)**: 새로 생성된 상태, 영속성 컨텍스트와 무관
  2. **영속 (Managed)**: 영속성 컨텍스트에 저장된 상태
  3. **준영속 (Detached)**: 영속성 컨텍스트에서 분리된 상태
  4. **삭제 (Removed)**: 삭제하기로 예정된 상태
* **기능**:
  * 1차 캐시
  * 동일성 보장
  * 트랜잭션을 지원하는 쓰기 지연
  * 변경 감지 (Dirty Checking)
  * 지연 로딩

**평가:** ❌ 영속성 컨텍스트의 개념과 엔티티 생명주기에 대한 이해가 부족합니다.

**추가 키워드:** 1차 캐시, Dirty Checking, 지연 로딩, EntityManager

**면접 대응:** "영속성 컨텍스트는 엔티티를 관리하는 환경으로, 1차 캐시 역할을 합니다. 엔티티는 비영속, 영속, 준영속, 삭제의 4가지 상태를 가집니다."

***

#### Q3. JPA를 사용한 개발에서 N+1 문제가 무엇이며 이 문제가 발생하는 원인과 이를 해결하기 위한 대표적인 전략에 대해 설명해보세요.

**작성한 답안:** (답변 없음)

**모범답안:**

* **N+1 문제**: 하나의 쿼리로 N개의 데이터를 가져온 후, 연관된 데이터를 얻기 위해 N번의 추가 쿼리가 실행되는 문제
* **발생 원인**:
  * 지연 로딩 (Lazy Loading) 사용 시
  * 연관 관계의 데이터에 접근할 때마다 추가 쿼리 실행
* **해결 방법**:
  1. **Fetch Join**: JPQL에서 join fetch 사용
  2. **@EntityGraph**: 어노테이션으로 fetch 전략 지정
  3. **배치 사이즈**: @BatchSize로 IN 절 쿼리 최적화
  4. **즉시 로딩**: @OneToMany(fetch = FetchType.EAGER)

```java
// Fetch Join 예시
@Query("SELECT u FROM User u JOIN FETCH u.orders")
List<User> findAllWithOrders();
```

**평가:** ❌ 답변하지 않았습니다. 중요한 개념이므로 반드시 학습이 필요합니다.

**추가 키워드:** 지연 로딩, 즉시 로딩, Fetch Join, @EntityGraph, @BatchSize

**면접 대응:** "N+1 문제는 지연 로딩으로 인해 1번의 쿼리 후 N번의 추가 쿼리가 발생하는 문제입니다. Fetch Join이나 @EntityGraph로 해결할 수 있습니다."

***

### 8. Web & Network

#### Q1. 네트워크 연결에서 ip와 port가 어떤 역할을 하는지 설명해보세요.

**작성한 답안:** ip는 네트워크상에서의 주소, port는 해당 ip가 가지고 있는 출입구?? 특정 서비스는 사용하는 포트가 정해져있다.

**모범답안:**

* **IP (Internet Protocol) 주소**: 네트워크상에서 컴퓨터를 식별하는 고유한 주소
  * 32비트(IPv4) 또는 128비트(IPv6)
  * 예: 192.168.1.1
* **Port**: 하나의 컴퓨터에서 여러 서비스를 구분하기 위한 번호
  * 16비트 숫자 (0-65535)
  * Well-known ports: HTTP(80), HTTPS(443), SSH(22), FTP(21)

**비유**: IP는 아파트 주소, Port는 호수

**평가:** ✅ 기본 개념은 정확합니다!

**추가 키워드:** IPv4/IPv6, Well-known ports, 소켓

**면접 대응:** "IP는 네트워크에서 컴퓨터를 식별하는 주소이고, Port는 해당 컴퓨터에서 실행되는 특정 서비스를 구분하는 번호입니다."

***

#### Q2. 쿠키와 세션의 차이에 대해서 설명해보세요.

**작성한 답안:** 쿠키는 클라이언트에서 저장하는 것. 세션은 서버쪽에서 저장하는 데이터

**모범답안:**

* **쿠키 (Cookie)**:
  * 클라이언트(브라우저)에 저장
  * 보안에 취약 (클라이언트에서 변조 가능)
  * 만료 시간 설정 가능
  * 용량 제한 (4KB)
* **세션 (Session)**:
  * 서버에 저장
  * 보안에 안전 (서버에서 관리)
  * 브라우저 종료 시 삭제
  * 서버 메모리 사용

**사용 예시**:

* 쿠키: 자동 로그인, 사용자 설정
* 세션: 로그인 상태, 장바구니

**평가:** ✅ 기본 개념은 정확하지만, 보안성과 용량 등의 특징 설명이 부족합니다.

**추가 키워드:** 보안성, 용량 제한, 만료 시간, 상태 관리

**면접 대응:** "쿠키는 클라이언트에 저장되어 속도는 빠르지만 보안에 취약하고, 세션은 서버에 저장되어 안전하지만 서버 자원을 사용합니다."

***

#### Q3. 크롬 브라우저의 주소 창에 'www.google.com'을 입력하고 엔터를 치면 일어나는 일을 최대한 아는대로 적어보세요.

**작성한 답안:** DNS에서 해당 주소에 해당하는 ip를 받아와서 라우터를 거치며 해당 IP를 가진 컴퓨터를 찾는다. 컴퓨터에서 본인의 MAC 주소로 응답하면 그 MAC 주소로 찾아감. 구글이라고 쳤다면 구글 서버에서 구글 페이지 html을 보내줘서 페이지에 구글 페이지가 뜨는것

**모범답안:**

1. **URL 파싱**: 브라우저가 URL을 분석
2. **DNS 조회**: 도메인 이름을 IP 주소로 변환
   * 브라우저 캐시 → OS 캐시 → 라우터 캐시 → ISP DNS → 루트 DNS
3. **TCP 연결**: 3-way handshake로 서버와 연결 설정
4. **HTTP 요청**: GET 요청을 서버로 전송
5. **서버 처리**: 웹 서버가 요청을 처리하고 응답 생성
6. **HTTP 응답**: HTML, CSS, JS 등을 클라이언트로 전송
7. **렌더링**: 브라우저가 HTML을 파싱하여 DOM 트리 생성
8. **리소스 로딩**: CSS, JS, 이미지 등 추가 리소스 다운로드
9. **페이지 표시**: 최종적으로 웹 페이지를 화면에 렌더링

**평가:** ⚠️ DNS와 기본적인 통신 과정은 이해했지만, TCP 연결, HTTP 프로토콜, 브라우저 렌더링 과정이 누락되었습니다.

**추가 키워드:** TCP 3-way handshake, HTTP 프로토콜, DOM 렌더링, 브라우저 캐시

**면접 대응:** "DNS 조회로 IP를 얻고, TCP 연결 후 HTTP 요청을 보냅니다. 서버가 HTML을 응답하면 브라우저가 파싱하여 DOM을 생성하고 렌더링합니다."

***

### 📚 학습 우선순위 및 추천 사항

#### 🔴 즉시 학습 필요 (틀린 개념)

1. **Java 오버로딩/오버라이딩** - 개념이 뒤바뀜
2. **OOP 클래스/객체/인스턴스** - 기본 개념 부족
3. **JVM과 Java 특징** - 구체적 이해 부족
4. **JPA 영속성 컨텍스트** - 핵심 개념 미흡
5. **JPA N+1 문제** - 답변 없음

#### 🟡 보완 학습 필요 (개념은 맞으나 부족)

1. **운영체제 역할** - 구체적 기능들 추가
2. **예외 처리** - finally, checked/unchecked exception
3. **DB 인덱스** - B-Tree 구조 이해
4. **Spring IoC/DI** - 구체적 장점과 원리
5. **웹 통신 과정** - TCP, HTTP, 렌더링 과정

#### ✅ 잘 이해한 부분

* CS 기초 (CPU, RAM, Storage)
* 프로세스/스레드 개념
* 동기/비동기 개념
* Java 접근 제어자
* 배열과 연결리스트 차이
* 생성자 개념
* 캡슐화 개념
* 쿠키/세션 차이

#### 💡 면접 팁

1. **정의 → 특징 → 예시** 순으로 답변
2. **키워드를 정확히 사용**하여 전문성 어필
3. **구체적인 예시**로 이해도 증명
4. **비교 질문**에서는 차이점을 명확히 구분
5. **모르는 것은 솔직히** 인정하되, 관련 지식으로 연결
